\chapter{Fundamentação teórica}

Nesta introdução teórica, será abordado o funcionamento básico das redes de petri e alguns dos principais tipos existentes. É importante compreender esses conceitos fundamentais antes de prosseguir para a implementação de \textit{software}, pois definirá a ideia de funcionamento e implementação, onde poderá se observar a utilidade das redes, possíveis abstrações e comportamentos desejados, como os de interesse abordados na seção de introdução. Também conceitos relacionados a implementação de \textit{software} e outros conceitos adjacentes necessários ao entendimento do desenvolvimento das partes integrantes do trabalho.

\section{Redes de petri}

As redes de petri são uma poderosa ferramenta para a modelagem e análise de sistemas concorrentes e paralelos. Introduzidas por Carl Adam Petri em 1962 \cite{carlpetri}, as redes de petri fornecem uma representação gráfica e formal para descrever a dinâmica de sistemas complexos, permitindo a análise de propriedades importantes, como comportamento temporal, concorrência e paralelismo.

Uma rede de petri é composta por lugares, transições, fichas e arcos. Cada componente tem um papel fundamental na representação e modelagem do sistema.

\begin{itemize}
	\item Lugares: Os lugares representam estados ou condições do sistema. Eles são representados por círculos em um diagrama de rede de petri. Os lugares podem conter fichas, que são unidades discretas que refletem o estado atual do sistema.
	
	\item Transições: As transições representam eventos ou ações que podem ocorrer no sistema. Elas são representadas por retângulos em um diagrama de rede de petri. Para que uma transição seja disparada, é necessário que todos os lugares de entrada estejam marcados com pelo menos uma ficha.
	
	\item Fichas: As fichas são unidades discretas que se movem entre os lugares em resposta à ocorrência das transições. Elas refletem o estado atual do sistema e representam o fluxo de controle. Quando uma transição é disparada, ela consome as fichas dos lugares de entrada e produz novas fichas nos lugares de saída.
	
	\item Arcos: Os arcos conectam os lugares às transições e vice-versa. Eles indicam as relações de dependência entre os elementos do sistema. Existem dois tipos de arcos: arcos de entrada, que conectam lugares a transições, indicando que os lugares são precondições para a ocorrência da transição, e arcos de saída, que conectam transições a lugares, indicando que as transições produzem fichas nos lugares de saída. Estes arcos podem ainda conter pesos, desta forma, um arco de entrada pode retirar mais de uma ficha de um lugar, ou um arco de saída pode inserir várias fichas em outro lugar.
\end{itemize}

\begin{figure}[ht]
	\centering
	\caption{Rede de petri com dois lugares e uma transição}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/samplepetri}\\
	\label{fig:samplepetri}
\end{figure}

\pagebreak

O funcionamento de uma rede de petri ocorre através de um processo chamado de disparo. Quando todas as condições de precondições de uma transição são satisfeitas, a transição é disparada, consumindo as fichas dos lugares de entrada e produzindo fichas nos lugares de saída correspondentes. Esse processo de disparo ocorre de forma determinística, onde as transições só podem ser disparadas quando todas as condições são atendidas.

Em mais detalhes, as fichas só se movem de um lugar ao outro caso uma transição aconteça, e ela só irá acontecer se o arco for atendido, por exemplo, o arco de peso de saída só irá permitir que a transição ocorra caso a quantidade de fichas no lugar de origem for maior ou igual ao peso, efetivamente colocando uma condição de disparo. Quando todas as condições atreladas a uma transição são atendidas, tal transição diz se sensibilizada. 

\subsection{Tipos de Redes de petri}

Existem vários tipos de redes de petri, cada um com suas características e aplicabilidades específicas. Alguns dos principais tipos são:

\begin{itemize}
	\item Redes de petri coloridas \cite{coloredpetrinets}: Nesse tipo de rede, além das fichas, são utilizadas cores para representar diferentes propriedades ou atributos dos elementos do sistema. Isso permite uma modelagem mais expressiva, onde as cores das fichas podem influenciar o comportamento das transições.
	
	\item Redes de petri temporizadas \cite{petrinetmodeling}: Nesse tipo de rede, são adicionadas informações de tempo às transições e arcos. Essas informações podem incluir atrasos, tempo de execução ou intervalos de tempo específicos para a ocorrência de eventos. Isso possibilita a análise de propriedades temporais e a simulação de sistemas baseados em tempo.
	
	\item Redes de petri estocásticas \cite{stochasticpetrinets}: Nas redes de petri estocásticas, são incorporadas probabilidades às transições e arcos, permitindo a modelagem de sistemas com comportamento probabilístico. Essas redes são úteis para a análise de sistemas em que a ocorrência de eventos é incerta ou aleatória.
	
	\item Redes de petri priorizadas \cite{petrinetmodeling}: Redes onde as transições tem a propriedade de serem priorizadas para disparo em relação ao outras, úteis em caso de disparo simultâneo de uma ou mais transições.

	\item Redes de petri de alto nível \cite{highlevelpetrinets}: As redes de petri de alto nível são uma extensão das redes de petri tradicionais, que permitem uma representação mais abstrata e simplificada dos sistemas. Elas são úteis para modelar sistemas complexos e lidar com a explosão combinatória que pode ocorrer em redes de petri tradicionais. Abstrações como lugares compartilhados, macro transições e hierarquia de sub-redes são utilizadas para simplificar a representação e análise desses sistemas.
\end{itemize}

Esses são apenas alguns dos principais tipos de redes de petri, e cada um deles oferece recursos e abordagens específicas para a modelagem e análise de sistemas. O uso correto e adequado desses tipos de redes de petri depende das características do sistema a ser modelado e das propriedades que se deseja analisar. 

\subsection{Delimitação de uma rede para uso industrial}

As redes de petri são particularmente interessantes, pois apresentam um bom grau de flexibilidade e capacidade de abstração, podendo comportar lógicas completas, simples e robustas, então é de interesse delimitar o tipo de rede que deverá ser trabalhada de forma que possamos ter as funcionalidades e características para modelagem de sistemas, como preferência para sistemas de automação industrial. 

O \textit{software} Petrilab \cite{de2015petrilab} abre o caminho com uma delimitação interessante e prática para uso industrial, onde se propõe a utilização de métodos de entrada e saída para rede de petri, condições lógicas que permitem o acionamento de transições e os tipos de arcos desejados, sendo eles os de peso e arcos negados. Baseado neste trabalho podemos construir e reavaliar algumas decisões sobre a definição da rede de petri. 

Particularmente no uso industrial a utilização de temporização é indispensável para qualquer tipo de processo, então esse é um pré-requisito inegociável. Em nome da implementação multi plataforma e considerando também precisão, será definido que as transições temporizadas trabalhem com milissegundos em vez de microssegundos. Um exemplo de transição temporizada pode ser visto na figura \ref{fig:petritime}. 

\begin{figure}[ht]
	\centering
	\caption{Rede de petri com transição temporizada}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/petritime}\\
	\label{fig:petritime}
\end{figure}

Os arcos com peso são úteis, porém é fácil encontrar situações onde algumas abstrações se fazem convenientes, como no caso de realizar a retirada de todos as fichas de um lugar de uma só vez, um comedor de fichas, figura \ref{fig:comedor}, cujo trabalho é exatamente este. Conforme a lógica desejada, tal comportamento pode ser também atrelado a outro tipo de arco, o arco de \textit{reset} (reinicialização) \cite{ResetNetsBetweenDecidabilityAndUndecidability}, não presente na implementação do Petrilab, onde após o disparo de uma transição o mesmo irá remover todos as fichas do lugar atrelado, sendo essa relação não direcional, como nos arcos de peso. Um exemplo de arco de \textit{reset} pode ser visto na figura \ref{fig:reset}. 

\begin{figure}[ht]
	\centering
	\caption{Configuração comedor de fichas}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/comedor}\\
	\label{fig:comedor}
\end{figure}

\begin{figure}[ht]
	\centering
	\caption{Arco de \textit{reset}}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/reset}\\
	\label{fig:reset}
\end{figure}

Ainda há mais um tipo de arco de interesse, por vezes pode ser necessário a criação de lógicas de exclusão mútua, ou de verificação simples, podendo vir a utilizar um arranjo lógico de lugares e transições dedicado, tendo a função de detectar quando não há fichas em lugar, comportamento que pode ser alcançado com um único arco, o arco de negado, também chamado de arco inibidor, que somente permite o disparo de uma transição quando não há fichas em um determinado lugar.

\begin{figure}[ht]
	\centering
	\caption{Arco negado, ou inibidor}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/negado}\\
	\label{fig:negado}
\end{figure}

Tal arco permite abstrações mais simples mas também possibilita que nossa rede de petri seja computacionalmente completa \cite{petrinetTuringComplete}, ou seja, teoricamente ela pode vir a computar qualquer problema, propriedade útil quando desejamos que nossa rede de petri seja capaz de modelar qualquer tipo de sistema visando a automação industrial, e também que isso seja feito de forma conveniente.  

Ainda para o uso industrial devemos nos perguntar como podemos interagir com a rede de petri em \textit{software} com o processo/sistema atrelado, para isso necessitamos de entradas e saídas. As entradas devem ser atreladas as transições, pois são estas que movem o estado da rede.

A forma como as entradas são atreladas é baseada no seguinte fato, se uma rede de petri é disparada continuamente, em tempo real, toda transição é sempre executada quando possível, e se atrelarmos o estado binário de uma entrada à capacidade de disparo de uma transição, a mesma pode ser levada ao disparo várias vezes por ciclo, podendo ocasionar um comportamento indesejado, portanto se propõe a utilização de eventos instantâneos para ativação. No caso de entradas discretas, estes eventos são as bordas, de subida ou descida, que acontecem quando a entrada muda de estado e duram por apenas um ciclo de execução, garantindo disparos únicos de transições, sendo na subida, descida, ou ambos, da entrada.

No Petrilab são dadas como entradas também, de certa forma, condições lógicas não baseadas em eventos. Na implementação aqui proposta, iremos descartar essas condições em nome da simplicidade, pois esse tipo de funcionalidade pode ser alcançado por uma abstração com alguns lugares e transições extras, ficando a critério do autor da rede.

As saídas podem se referir ao estado interno da rede, ou seja, as fichas nos lugares, então é de livre escolha a forma como podemos retirar a informação da rede de como acionar as saídas. Propõe-se a utilização de comparações do tipo maior ou igual entre um número de fichas e a quantidade de fichas em determinado lugar, tal condição é binária e será atrelada a uma saída externa.

Nada impede também a utilização da própria quantidade de fichas seja a saída, caso deseje se uma saída numérica, que pode ser acessada diretamente do lugar da rede de petri.

\subsection{Implementação de redes de petri em \textit{software}}

Não nos atrelando a definição formal matemática das redes de petri, é necessário abordar a representação dessas redes, de maneira computacional na forma de \textit{software}, e existem dois jeitos clássicos de realizar essa representação, de forma relacional ou matricial.

A forma relacional trata lugares e transições como vértices de um gráfico direcionado, e em código há uma lista de lugares e transições e uma lista de relações, onde cada relação é atrelada a um lugar e transição e possui metainformação sobre o tipo de relação, como o próprio tipo, que pode ser um arco direcionado de peso, um arco negado ou de \textit{reset}. Esse tipo de representação é mais compreensível e intuitiva, porém pode sofrer impactos de desempenho, pois para realização de verificações e disparos da rede é necessário percorrer estas listas para cada tipo de operação distinta.

A outra forma, matricial, declara-se uma matriz de arcos, onde as linhas são os lugares, e as colunas as transições, e o valor em determinada posição determina a quantidade de fichas a serem movidas, como no caso de arcos de peso. Este tipo de implementação é mais simples e rápida, pois não há necessidade de percorrer as relações, que é uma operação de tempo linear, porém a representação matricial cresce quadraticamente conforme mais lugares e transições são atrelados, aumentando consumo de memória e armazenamento. 

Dado que o tamanho de redes de petri não são usualmente grandes, e que há prioridade de processamento sobre memória, será escolhida a representação matricial para implementação em \textit{software} da rede de petri proposta. Tal representação acomoda tranquilamente os tipos de arcos propostos, bem como temporização e de entrada e saída.

\lstinputlisting[
	language=C,
	caption={Inicialização de uma rede de petri de forma matricial},
	sourcePrefix={Fonte: },
	source={Do autor.},
	label=code:pnetnew
]{code/pnetnew.c}

\subsection{Limitações e comportamento}
\label{section:limitations}

Seja qual for o paradigma de implementação escolhido, motor de execução a ser implementado, há algumas situações a serem abordadas, detalhes de implementação que irão afetar o comportamento geral de execução da rede e que devem ser delimitados e abordados de forma a garantir equivalência das implementações.

\subsubsection{Disparos simultâneos}

Quando duas transições estão sensibilizadas simultaneamente, no momento do disparo qual deve ser o comportamento? Há algumas formas de pensar sobre tal dilema. Uma possível solução seria a utilização de rede de petri priorizadas em que uma transição é priorizada sobre outra, garantindo assim que apenas umas delas dispare por vez.

Outra maneira é garantir a propriedade de unicidade, ou seja, que apenas uma transição seja executada por vez. Há duas formas de garantir isso, permitindo que apenas uma transição seja sensibilizada por vez, ou que várias sejam sensibilizadas mas apenas o disparo de uma seja efetuado. Visto que será realizada a implementação de transições temporizadas, deve-se pensar que várias transições podem ser marcadas como sensibilizadas a fim de serem temporizadas e disparadas posteriormente, como discutido na seção \ref{section:delay}. 

Portanto, irá se permitir a sensibilização de várias transições, mas apenas uma poderá ser disparada por vez em um ciclo de execução. O processamento dos disparos será parado após o primeiro disparo, que será realizado na transição sensível de menor índice, o que pode por vezes causar ambiguidade sobre qual transição será disparada antes.

Pelo fato de desejarmos que a rede seja temporizada, de entrada/saída e de ser executada em tempo real, diminui-se naturalmente a probabilidade que haja colisão de disparo entre uma ou mais transições ao mesmo tempo, devido às entradas virem de um sistema físico real em tempo real e de algumas transições serem temporizadas. 

Assim, deixa se um aviso de ambiguidade para este tipo de implementação, pois mesmo que que seja garantido o disparo de uma só transição, eliminando o dilema do disparo mútuo, ainda pode-se ocorrer ambiguidade sobre qual transição será disparada na rede, porém menos comum, dado o tipo de rede trabalhada. Fica assim à critério do autor da rede de petri garantir que, para que uma transição seja priorizada em uma situação de ambiguidade, que a mesma seja de menor índice ou que se empregue um mecanismo auxiliar com outros lugares e transições para garantir o comportamento desejado. 

\subsubsection{Entradas}

Como discutido anteriormente, as entradas são dadas como eventos atrelados a transições, e com a mesma preocupação de disparos simultâneos existem dois casos a serem considerados, transições com múltiplos eventos de entrada, e várias transições que utilizam a mesma entrada.

Para fins de simplificação será reforçado que cada transição seja atrelada unicamente a uma entrada e vice-versa, garantindo que disparos simultâneos causados pela mesma entrada nunca ocorram. Caso a mesma entrada seja atrelada a várias transições, pode haver ambiguidade, pelo fato das transições dependerem do mesmo evento no mesmo ciclo de execução.

Casos onde deseja-se tal comportamento, pode-se fácil e seguramente ser implementado utilizando múltiplas transições e lugares auxiliares, deixando assim essa abstração de responsabilidade do autor da rede de petri.

\subsection{Temporização}
\label{section:delay}

As transições temporizadas funcionam como retardos de tempo. Dado uma transição que depende de um evento de entrada e de arcos condicionais, como arcos de peso e arcos negados, está começará a contar a partir do momento que todas as condições forem satisfeitas. A contagem é realizada até o tempo determinado, onde a transição será disparada somente se as condições dos arcos ainda permanecem verdadeiras. Se as condições permitirem e a transição for sensibilizada novamente, a contagem atual deve continuar normalmente até que a transição tenha chance de tentar disparar, momento em que será liberada para iniciar a contagem novamente se requerido. 

As transições não temporizadas devem ser disparadas de forma individual, já as temporizadas podem começar a contar de forma simultânea, porém, devem ser disparadas também de forma individual. Em caso de conflito, da mesma forma que para as transições normais, a transição de menor índice nas matrizes receberá prioridade. 

O razão dessa definição tem como base garantir o funcionamento correto das transições temporizadas nos seguintes casos:

\begin{itemize}
	\item Transições temporizadas sem entrada e com arcos condicionais. Devem começar a contagem logo que os arcos condicionais permitirem o disparo. 
	\item Transições temporizadas com entrada e sem arcos condicionais. Devem começar a contagem assim que o evento de entrada for verdadeiro. 
	\item Transições temporizadas com entrada e com arcos condicionais. Devem começar a contagem assim que o evento de entrada for verdadeiro, porém o disparo só acontece se ao final da contagem os arcos de condição forem satisfeitos. 
	\item Transições temporizadas sem entrada e sem arcos condicionais. Nunca serão sensibilizadas e disparadas. 
\end{itemize}

Tal definição evita que, por exemplo, uma transição sem evento de entrada, fique tentando contar o tempo de retardo, situação que pode evitar que a mesma dispare mesmo que os arcos condicionais permitam, pois a mesma estará contando repetidamente, e poderá somente ser disparada de forma períodica durante um pequeno espaço de tempo.

\section{Estruturas de dados e execução de código}

Quando se trata de programação de bibliotecas e artifícios\footnote{Pequena parte, fragmento, de um todo} de código, ou seja, código que será usado por terceiros, é necessário sempre se ter em mente que a implementação seja além de funcional, bem documentada e que seja robusta a erros, conceito que envolve, mas não é limitado a, tratamento de erros e exceções, visibilidade parcial da implementação, que esconde parte da funcionalidade evitando uso indesejado por parte do usuário, ou ainda a utilização de testes unitários, que testam partes individuais da biblioteca de forma automatizada. Então é necessário entender alguns conceitos de organização e execução de código por que garantirão nossas expectativas de funcionamento bem como irão garantir a robustez desejada a biblioteca. 

\subsection{Listas ligadas}

Listas ligadas, ou listas encadeadas, são estruturas de dados parecidas com listas normais, que são conjuntos de dados de mesmo tipo dispostos de forma sequencial por um índice numérico, já as listas ligadas não são. Elas ganham a denominação de lista, pois cada elemento guarda dentro de si mesmo uma referência para o próximo elemento da lista, de forma encadeada, daí o nome desse tipo de lista. 

Suas vantagens em relação às listas normais são que elas não tem espaço de memória predefinido e alinhado, elas podem crescer indefinidamente e de forma desorganizada com relação ao alinhamento de memória, são flexíveis, mas com o custo de terem de ser percorridas toda vez para se encontrar o elemento em dada posição, operação que tem um tempo de execução proporcional ao tamanho da lista, enquanto a lista normal faz isso de forma indexada, por isso é de tempo constante.

\begin{figure}[ht]
	\centering
	\caption{Lista ligada com dois nós}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/linked}\\
	\label{fig:linked}
\end{figure}

Para implementações em C a lista é basicamente um conjunto de nós, que são estruturas que guardam dentro de si um valor de tipo desejado, e um ponteiro de memória para outro nó na lista.

\subsection{Filas priorizadas}

Filas priorizadas são como filas normais, listas onde o elemento a ser inserido é colocado a frente e retirado ao fim, ou seja, quem entra primeiro sai primeiro. A lista priorizada implementa a funcionalidade de inserir elementos baseados em uma medida de privilégio que pode ser um número arbitrário ou uma medida como tempo de vida, uma escala de erro, etc. Da mesma forma que na fila normal, elementos são retirados ao fim da fila.

Podem ser implementados a partir de listas indexadas ou listas ligadas.

Um exemplo de fila priorizada seria uma onde processamos pacotes de entrega, sejam eles pacotes de protocolos de comunicação ou pacotes postais, onde temos uma lista ligada com dois pacotes de prioridade baixa, zero por exemplo, agora suponha que deseja-se processar um pacote com maior urgência, para tanto, se insere o pacote com seu valor de prioridade igual a um, assim a fila passa ter como último elemento o novo pacote, de prioridade maior.

\begin{figure}[ht]
	\centering
	\caption{Dinâmica da lista priorizada para pacotes}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/prio}\\
	\label{fig:prio}
\end{figure}

\subsection{\textit{Threads} e \textit{mutex locks}}

O processamento paralelo e concorrente são abordagens utilizadas para melhorar a eficiência e desempenho dos sistemas computacionais, permitindo a execução simultânea de múltiplas tarefas. No processamento paralelo, várias tarefas são executadas ao mesmo tempo, utilizando recursos computacionais simultaneamente. Isso é comumente aplicado em sistemas com múltiplos núcleos de processamento, onde diferentes tarefas podem ser executadas em paralelo, aumentando a capacidade de processamento total do sistema.

Uma das formas de alcançar o processamento paralelo é por meio do uso de \textit{threads}. As \textit{threads} são unidades básicas de execução em um programa, representando fluxos independentes de controle que podem executar tarefas em paralelo. Uma aplicação pode conter várias \textit{threads}, permitindo a execução simultânea de diferentes partes do código. As \textit{threads} compartilham o mesmo espaço de memória, o que facilita a comunicação e a troca de dados entre elas.

A execução concorrente de \textit{threads} também pode trazer desafios. Um problema comum é a ocorrência de \textit{race conditions}, que acontecem quando duas ou mais \textit{threads} acessam ou modificam uma região de memória, ou variável compartilhada simultaneamente, resultando em comportamento imprevisível do programa. Isso ocorre quando as operações das \textit{threads} não são adequadamente sincronizadas, resultando em um conflito entre as operações concorrentes. Para evitar \textit{race conditions}, são utilizados mecanismos de sincronização, como \textit{mutex locks}, \textit{mutex locks} são mecanismos de exclusão mútua, onde uma \textit{thread} obtém um lock para bloquear o acesso de outras \textit{threads} a um recurso compartilhado até que seja liberado. Isso garante que apenas uma \textit{thread} possa acessar o recurso por vez, evitando \textit{race conditions}. Os \textit{mutex locks} são usados para proteger regiões críticas do código onde ocorrem operações compartilhadas, garantindo a consistência e prevenindo conflitos entre as \textit{threads}.

\begin{figure}[ht]
	\centering
	\caption{Processamento concorrente usando \textit{mutex}}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/mutex}\\
	\label{fig:mutex}
\end{figure}

\subsection{\textit{Threads} e \textit{callbacks}}

Em utilização normal, quando um \textit{thread} precisa acessar um recurso protegido, ela solicita o bloqueio do \textit{mutex}, aguardando até que ele esteja disponível. Isso impede que outras \textit{threads} acessem o recurso simultaneamente, evitando \textit{race conditions}. Uma vez obtido o bloqueio do \textit{mutex}, a \textit{thread} pode acessar o recurso de forma segura, realizar as operações necessárias e, ao finalizar, deve desbloquear o \textit{mutex} para permitir que outras \textit{threads} possam acessar o recurso. Dessa forma, o uso adequado de \textit{mutex}es permite controlar a execução e garantir a sincronização correta entre as \textit{threads}, evitando conflitos e garantindo a integridade dos dados compartilhados.

A utilização de \textit{callbacks} é uma forma comum de comunicação entre dois \textit{threads} em programação concorrente. Um \textit{callback} é uma função ou bloco de código que é passado como argumento para outra função. Ao utilizar \textit{callbacks} para comunicação entre \textit{threads}, um \textit{thread} pode registrar um \textit{callback} que será acionado quando uma determinada condição for atendida ou quando algum evento específico ocorrer. Essa abordagem é particularmente útil em situações em que um \textit{thread} precisa notificar outro \textit{thread} sobre algo que aconteceu. Por exemplo, considere um cenário em que um \textit{thread} A está aguardando a conclusão de um processamento realizado pelo \textit{thread} B. Em vez de ficar bloqueado a execução, esperando o \textit{thread} B terminar, o \textit{thread} A pode registrar um \textit{callback} que será executado pelo \textit{thread} B assim que o processamento for concluído. Dessa forma, o \textit{thread} A pode continuar executando outras tarefas sem ficar preso esperando a finalização do \textit{thread} B.

A utilização de \textit{callbacks} nesse contexto permite uma abordagem assíncrona de comunicação, na qual os \textit{threads} podem operar de forma independente e notificar uns aos outros quando necessário. Além disso, a flexibilidade dos \textit{callbacks} permite que o código de um \textit{thread} possa ser modificado ou estendido sem afetar diretamente o código do outro \textit{thread}, tornando o sistema mais modular e adaptável. No entanto, é importante considerar questões de sincronização e concorrência ao utilizar \textit{callbacks} entre \textit{threads}. Mecanismos adequados, como \textit{mutex locks} ou semáforos\footnote{Mecanismo de sincronização análogo a um semáforo de trânsito, onde só se executa código quando houver um ``sinal verde'', que é dado pelo outro ator de execução}, devem ser empregados para garantir a correta sincronização e evitar problemas de \textit{race conditions} ou acesso simultâneo a recursos compartilhados.

Tratando de implementações, mais específico em C, \textit{callback} são funções e tem formatos distintos, e geralmente são passados como ponteiros de função. Normalmente \textit{callbacks} são dados como funções genéricas que não retornam nada e recebem também informações genéricas, usado \lstinline{void*}.

\lstinputlisting[
	language=C,
	caption={Implementação usual de callbaks em C},
	sourcePrefix={Fonte: },
	source={Do autor.},
	label=code:callback
]{code/callback.c}

A implementação desses conceitos em C pode ser alcançada através da biblioteca \lstinline{pthreads} \cite{pthreads}, biblioteca de paralelismo/concorrência padrão em sistema que suportam POSIX e a mais difundida das implementações, geralmente presente em sistemas operacionais por padrão.    

\subsection{Temporização}

Temporizadores são um tópico interessante em si, pois em sistemas embarcados geralmente têm-se acesso a temporizadores de \textit{hardware}, que são precisos e fáceis de usar, porém, para sistemas operacionais que não são de tempo real e não possuem temporizadores de \textit{hardware} disponíveis a nível de usuário, acabam se tornando um leve problema. A maneira como pode-se implementar um temporizador seria na criação de uma execução paralela/concorrente de código onde pode-se contar o tempo através de chamadas de função que retornam o tempo passado desde um ponto arbitrário, como a execução do sistema ou da própria aplicação, valor que pode ser impreciso em cima do fato de ainda estar sendo contado continuamente em uma rotina concorrente, que não é garantida de ser executada em tempo real. O resultado é que podemos alcançar timers com boa acurácia, na casa dos milissegundos, porém com baixa precisão, com bastante variação em torno do valor original de contagem.

A utilização de execução concorrente de código pelo uso de \textit{threads} recaí sobre a capacidades da maioria dos sistemas, sejam computadores pessoais ou sistemas embarcados, portanto trata-se de uma boa escolha para implementação genérica. Há ainda a possibilidade de se utilizar temporizadores de \textit{hardware} de forma condicional conforme a arquitetura envolvida, o que adiciona um grau de complexidade ao sistema de compilação e deve ser alterado pontualmente para cada sistema a ser suportado, portanto, uma boa escolha para projetos mais especializados e menos genéricos.

Para realizar a medição utiliza se a função \lstinline{clock} da biblioteca padrão C. Essa função retorna o tempo de CPU decorrido desde o início do programa em ciclos de \textit{clock}, que podem ser convertidos em unidades de tempo, como milissegundos. A função \lstinline{clock} oferece uma forma padronizada de obter-se a temporização, independentemente do sistema operacional, garantindo maior portabilidade e precisão, no entanto, é importante ressaltar que a função \lstinline{clock} mede o tempo de CPU decorrido e não segue de fato o tempo real.

A utilização normalmente recai sobre o paradigma de obter se o tempo inicial e calcular o tempo decorrido subtraindo chamadas seguintes a função até que a diferença entre elas seja maior ou igual ao tempo desejado. 

\lstinputlisting[
	language=C,
	caption={Temporizador de \SI{1}{s} em C},
	sourcePrefix={Fonte: },
	source={Do autor.},
	label=code:timer
]{code/timer.c}

\section{Programação de PLC's}

\subsection{IEC 61131-3}

A norma IEC 61131-3 \cite{IEC611313} é um padrão internacional amplamente utilizado para a programação de controladores lógicos programáveis (PLCs) e sistemas de automação industrial. Ela foi desenvolvida pela Comissão Eletrotécnica Internacional (\textit{International Electrotechnical Commission} - IEC) e define uma linguagem comum e um ambiente de programação para PLCs.

Uma das principais características da norma IEC 61131-3 é a definição de cinco linguagens de programação padronizadas para PLCs. Essas linguagens são: diagrama de contatos (\textit{LD - Ladder Diagram}), lista de instruções (\textit{IL - Instruction List}), texto estruturado (\textit{ST - Structured Text}), diagrama de blocos de função (\textit{FBD - Function Block Diagram}) e gráfico sequencial (\textit{SFC - Sequential Function Chart}). Cada linguagem tem sua própria sintaxe e semântica, permitindo aos programadores escolher a linguagem mais adequada para a tarefa em questão.

Além das linguagens de programação, a norma IEC 61131-3 também estabelece diretrizes para a organização e estruturação de programas PLC, o uso de variáveis, a manipulação de tempo, a comunicação com dispositivos externos e a interface com o \textit{hardware} do PLC. Essas diretrizes garantem a interoperabilidade entre diferentes PLCs e facilitam a portabilidade de programas entre diferentes sistemas.

Outro aspecto importante da norma IEC 61131-3 é a definição de blocos de função reutilizáveis. Esses blocos são unidades de \textit{software} que encapsulam uma funcionalidade específica e podem ser usados em diferentes programas e projetos. Eles promovem a modularidade, a reutilização de código e a manutenção simplificada, permitindo um desenvolvimento mais eficiente e flexível de sistemas de automação.

A norma também aborda aspectos relacionados à segurança funcional, especificando requisitos para garantir a integridade e confiabilidade dos sistemas de automação. Ela define categorias de segurança e diretrizes para a programação de funções de segurança, como monitoramento de entradas, lógica de falha segura e supervisão de sistemas.

\subsection{Lista de instrução}

Uma das linguagens padronizadas para programação de PLC's é a lista de instrução \cite{IEC11313}, que consiste em uma sequência de instruções que especificam as operações a serem executadas pelo PLC afim de controlar o comportamento do sistema desejado. Dentre os comandos mais comuns presentes destacam-se o \lstinline{LD} (Load), \lstinline{ST} (Store), \lstinline{S}, \lstinline{AND} dentre outros.

O comando \lstinline{LD} (Load) é utilizado para carregar um valor ou estado lógico em uma variável interna ou memória do PLC. Essa instrução é fundamental para a atribuição de valores a variáveis e para a leitura de entradas do sistema.

O comando \lstinline{ST} (Store) é responsável por escrever um valor lógico em uma memória, geralmente uma memória interna ou saída do PLC. Caso referencie uma saída, irá se controlar a ativação ou desativação de dispositivos externos.

O comando \lstinline{S} é utilizado para definir um estado lógico específico em variáveis internas do PLC. Esse comando é útil para inicializar variáveis ou para acionar estados específicos em situações de controle. Diferente do comando \lstinline{ST}, esta instrução apenas grava o valor lógico ``verdadeiro'' em uma variável, permanecendo assim até seja alterado por outra instrução.

O comando \lstinline{AND} realiza a operação lógica ``e'' entre dois ou mais valores. Ele permite realizar condições de controle mais complexas ao combinar múltiplas entradas.

Estes comandos basicamente dão ordem de execução a um programa. Um programa é formado por seções, cada seção de execução individualmente e em ordem sequencial. Para cada seção, é primeiramente carregado um valor, usando por exemplo \lstinline{LD}, seguido então por alguma lógica, e por fim direcionando o resultado para uma memória interna ou saída física, usando por exemplo \lstinline{ST} ou \lstinline{S}.

Um exemplo de seção seria abrir uma variável e escrever seu valor em uma saída.

\lstinputlisting[
	language=C,
	caption={Seção de entrada e saída em lista de instrução},
	sourcePrefix={Fonte: },
	source={Do autor.},
	firstline=1,
	lastline=2,
	label=code:iliec
]{code/iliec.txt}

\subsection{Referência WEG TPW04}

A definição de lista de instrução é padronizada, porém, fabricantes optam por realizar implementações que abrangem a norma em grande parte, mas que por vezes apresentam diferenças e particularidades. Da empresa WEG, o modelo de PLC TPW04 \cite{wegtpw04}, pode apresentar algumas diferenças em relação à definição da norma IEC 61131-3. Essas diferenças podem ocorrer devido a recursos específicos do PLC como otimizações de desempenho ou necessidades específicas do ambiente de automação em que o TPW04 é utilizado. É importante ressaltar que as diferenças podem variar dependendo da versão do firmware do TPW04. Aqui estão algumas possíveis diferenças.

\begin{itemize}
	\item Conjunto de Instruções: O TPW04 pode ter um conjunto de instruções específico que vai além das instruções definidas na norma IEC 61131-3. A WEG pode adicionar instruções adicionais para atender a requisitos específicos do PLC ou para fornecer recursos extras aos programadores.

	\item Sintaxe e Semântica: Embora o TPW04 siga os conceitos e princípios gerais da norma IEC 61131-3, pode haver diferenças sutis na sintaxe e nomenclatura das instruções. Essas diferenças podem ser introduzidas para simplificar a programação ou otimizar o desempenho do PLC.

	\item Recursos Específicos: O TPW04 pode oferecer recursos específicos que não estão incluídos na norma IEC 61131-3. Isso pode incluir recursos avançados de temporização, contadores específicos, funções de comunicação específicas ou suporte para dispositivos periféricos exclusivos da WEG.
\end{itemize}

Para a referência WEG, existem algumas extensões e renomeações dos comandos definidos pela norma. Um exemplo de instrução específica WEG para o TPW04 seriam as bordas de subida, \lstinline{LDP}, e descida \lstinline{LDF}, que são utilizadas para controlar a ocorrência de eventos específicos no sistema. As bordas de subida são acionadas quando um sinal lógico muda de zero para um, enquanto as bordas de descida são acionadas quando o sinal lógico muda de um para zero. Essas bordas são fundamentais para a detecção de transições e acionamento de ações em tempo real.

Também há temporizadores, que são componentes essenciais na programação de controladores lógicos programáveis. Eles permitem a criação de atrasos programados e temporizações precisas, sendo utilizados para controlar o tempo de espera entre eventos e para executar ações em momentos específicos. Os temporizadores podem ser configurados para atrasos fixos ou variáveis, dependendo das necessidades do sistema.

Por fim temos alguns comandos que são de extrema importância, pois possibilitam a reutilização de uma mesma computação várias vezes, os comandos \lstinline{MPS} (Memory push), inserir em memória, \lstinline{MRD} (Memory read), ler da memória, e \lstinline{MPP} (Memory pop), retirar da memória. Os comandos funcionam basicamente como uma pilha, onde o resultado de uma operação pode ser inserido com (\lstinline{MPS}), re-lido quantas vezes forem necessárias com (\lstinline{MRD}), e por fim lido a última vez, ao mesmo tempo que é retirado da pilha, (\lstinline{MPP}). Esses comandos são importantes para a coordenação e controle de programas em sistemas complexos, pois possibilitam atrelar várias saídas a um mesmo conjunto de condições.

Como este projeto visa a implementação prática para com o modelo TPW04, está será a referência a ser seguida para o desenvolvimento do compilador, respeitando as instruções específicas WEG, porém tentando utilizar as instruções mais triviais e gerais de forma a facilitar futuras adaptações para outras referências de outros modelos e fabricantes.

\subsection{Lista de instrução e \textit{Ladder}}

Uma das características da programação de PLC's é que pelo padrão IEC 61161-3, plataforma de programação de desses PLC's implementam um conjunto dessas linguagens, sendo mais usuais a linguagem \textit{Ladder} e de lista de instrução, e normalmente também fabricantes dão a habilidade aos programadores de alterar em tempo real entre as linguagens, isso é possível, pois todas são relativamente simples e normalmente podem ser traduzidas a partir da lista de instrução.

Assim, contanto que se tenha um método de tradução de uma dada linguagem para lista de instrução e vice-versa, há possibilidade do fabricante implementar essa tradução em tempo real.

A linguagem \textit{Ladder} em especial é um ótimo candidato, pois as operações mais básicas são facilmente mapeadas. No exemplo da figura \ref{fig:illadder}, temos um simples programa de PLC, onde pode-se observar um exemplo de implementação da relação entre as linguagem \textit{Ladder} e lista de instrução. Observa-se que para as ramificações \textit{Ladder} de entrada, utilizamos somente operações lógicas, uma operação lógica ``ou'' e outra ``e, negada'', assim, para entradas, a maior parte dos casos será uma expressão lógica em termos das entradas.

Para saída iremos utilizar as instruções de memória, inserindo o valor após a última operação lógica e depois lendo até a última entrada, onde o valor é retirado e a declaração do programa termina.

\begin{figure}[ht]
	\centering
	\caption{Exemplo de tradução entre \textit{Ladder} e lista de instrução referência WEG TPW04}
	%\incsvg{path/}{path/file}
	\incsvg{images}{images/illadder}\\
	\label{fig:illadder}
\end{figure}

Podem haver outras implementações e variações desta apresentada, porém, serve de ilustração para a capacidade de se converter entre as linguagens, provando em torno também que quando se tem um programa em lista de instrução, podemos facilmente alcançar outros paradigmas e linguagens, se tornando um ótimo alvo base para compilação de programas.

% \section{Aplicação gráfica}

% Editores visuais são provavelmente um dos tipos de aplicações gráfica mais comuns, pois conforme a evolução do computadores pessoais foi avançando, também foram as formas de interação, desde os consoles e telas puramente em texto para hoje dia interfaces e sistemas operacionais graficamente ricos. Em especial o tipo de programa WYSIWYG, do inglês, o que você é o que realmente é, ou seja, o que você interage na tela é realmente como é o produto final, contraste com aplicações como o sistema \LaTeX \cite{latex}, onde o resultado de saída, um arquivo PDF, não é o mesmo que foi editado, um aquivo de texto, sendo um exemplo de aplicação WYSIWYG o Libreoffice Writer \cite{writer}, um editor de texto capaz de realizar formatação, assim como o \LaTeX, mas onde você digita e imediatamente vê o resultado.

% Neste contexto de aplicações é 
