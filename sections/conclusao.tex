\chapter{Conclusão}

Dados os objetivos e aspirações deste projeto, pode-se afirmar que tanto a biblioteca em C quanto o algoritmo de compilação alcançaram o resultado esperado. Para biblioteca C \cite{github-pnet} pode-se listar as seguintes estatísticas de projeto:

\begin{itemize}
	\item Commits realizados: 42
 	\item Arquivos: 21
 	\item Linhas comentadas de código: 947
 	\item Linhas de código escrito: 3368
	\item Período de trabalho: Maio 2022 - Junho 2023
\end{itemize}

Dada as especificações de projeto delimitadas, a checagem e testes deixam a biblioteca C com aspecto robusto e de pronto uso. A execução e temporização funcionam com base na biblioteca padrão C e a biblioteca \lstinline{pthread}, e portanto, irão trazer performance e generalidade para aplicações desktop e compatibilidade com sistemas embarcados, através da implementação genérica a base de \textit{threads}.

Tendo opção de serialização da rede de petri em um formato de arquivo robusto, com versionamento e checagem de erro, capaz também de guardar estado, traz-se a possibilidade de um opção extra a compilação, onde dispositivos podem embarcar essas redes em formato de arquivo e carregá-las em memória no momento de execução.

A própria estrutura traz um aspecto trivial para utilização da mesma, seja na utilização das entradas e saídas de forma direta, no acesso ao estado interno, no aspecto assíncrono e também na parte da compilação, onde para maioria dos casos de utilização, dois laços de repetição, um para os lugares e outro para as transições, podem ser usados para varrer toda rede de petri, como por exemplo, utilizado na compilação para lista de instrução.

Trabalhos futuros podem ser feitos sobre a parte assíncrona de temporização visto que temos o objectivo de levar essa biblioteca para sistemas embarcados. A compilação condicional de um sistema assíncrono baseado em timers de \textit{hardware} traria toda precisão e acurácia que se espera do sistema embarcado, com a rede de petri nele embutida.

O algoritmo de compilação para rede de petri foi desenvolvido de maneira bastante simples, dado a estrutura da rede em mãos e o fato da lista de instrução já suportar alguns aspectos de arquitetura já de forma nativa, como eventos de borda e temporização, abrindo então portas para implementação de outras plataformas que também usam a lista de instrução, por vezes sendo extremamente similar a referência WEG TPW04 \cite{wegtpw04}. Podendo ainda também possuir conversão da lista para outras linguagens como o próprio \textit{Ladder}, aumentando o alcance dessa implementação além da própria lista de instrução.

Em sumo, os objetivos foram alcançados e espera-se que este trabalho sirva como semente para outras implementações e avanços, bem como sirva para difusão da utilização de redes de petri para modelagem de sistemas a eventos discretos, em especial a automação de sistemas industriais.